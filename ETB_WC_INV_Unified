-- Combined view integrating inventory matching and suppression rules
-- All CTEs from the base logic plus demand processing in one view

WITH p_norm AS (
    SELECT 
        p.*, 
        UPPER(LTRIM(RTRIM(CONVERT(varchar(255), 
            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(p.ORDERNUMBER, 'MO', ''), '-', ''), ' ', ''), '/', ''), '.', ''), '#', '')
        )))) AS CleanOrder,
        LTRIM(RTRIM(p.ITEMNMBR)) AS CleanItem,
        CASE 
            WHEN ISNUMERIC(LTRIM(RTRIM(p.Deductions))) = 1 THEN CAST(LTRIM(RTRIM(p.Deductions)) AS decimal(18, 5)) 
            ELSE 0 
        END AS CleanDeductions
    FROM 
        dbo.ETB_PAB_MO p
    WHERE 
        p.STSDESCR <> 'Partially Received'
        AND p.STSDESCR <> 'SCRAP'
        AND LTRIM(RTRIM(p.ITEMNMBR)) NOT LIKE '60.%'
        AND LTRIM(RTRIM(p.ITEMNMBR)) NOT LIKE '70.%'
),

m_norm AS (
    SELECT
        m.*, 
        UPPER(LTRIM(RTRIM(CONVERT(varchar(255), 
            REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(m.ORDERNUMBER, 'MO', ''), '-', ''), ' ', ''), '/', ''), '.', ''), '#', '')
        )))) AS CleanOrder,
        ROW_NUMBER() OVER (
            PARTITION BY UPPER(LTRIM(RTRIM(CONVERT(varchar(255), 
                REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(m.ORDERNUMBER, 'MO', ''), '-', ''), ' ', ''), '/', ''), '.', ''), '#', '')
            )))), m.FG
            ORDER BY m.Customer, m.[FG Desc], m.ORDERNUMBER
        ) AS rn_fg
    FROM 
        dbo.ETB_ActiveDemand_Union_FG_MO m
),

item_desc AS (
    SELECT 
        [Item Number] AS ItemNumber,
        ITEMDESC AS ItemDescription,
        UOMSCHDL
    FROM 
        dbo.Prosenthal_Vendor_Items
    WHERE 
        Active = 'Yes'
),

joined AS (
    SELECT
        CAST(COALESCE(NULLIF(LTRIM(RTRIM(p_norm.ORDERNUMBER)), ''), NULLIF(LTRIM(RTRIM(m_norm.ORDERNUMBER)), ''), '') AS varchar(255)) AS ORDERNUMBER,
        CAST(ISNULL(m_norm.Customer, '') AS varchar(255)) AS Construct,
        CAST(ISNULL(m_norm.FG, '') AS varchar(255)) AS FG,
        CAST(ISNULL(m_norm.[FG Desc], '') AS varchar(255)) AS [FG Desc],
        CAST(ISNULL(p_norm.ITEMNMBR, '') AS varchar(255)) AS ITEMNMBR,
        CAST(ISNULL(item_desc.ItemDescription, '') AS varchar(500)) AS ItemDescription,
        CAST(ISNULL(item_desc.UOMSCHDL, '') AS varchar(50)) AS UOMSCHDL,
        p_norm.STSDESCR,
        p_norm.DUEDATE,
        p_norm.[Expiry Dates],
        p_norm.[Date + Expiry],
        p_norm.MRPTYPE,
        p_norm.VendorItem,
        p_norm.PRIME_VNDR,
        p_norm.PURCHASING_LT,
        p_norm.PLANNING_LT,
        p_norm.ORDER_POINT_QTY,
        p_norm.SAFETY_STOCK,
        p_norm.Deductions AS Original_Deductions,
        p_norm.Expiry AS Original_Expiry,
        p_norm.[PO's] AS Original_POs,
        p_norm.Running_Balance AS Original_Running_Balance,
        CASE 
            WHEN ISNUMERIC(LTRIM(RTRIM(p_norm.BEG_BAL))) = 1 THEN CAST(LTRIM(RTRIM(p_norm.BEG_BAL)) AS decimal(18, 6)) 
            ELSE 0 
        END AS BEG_BAL_Num,
        p_norm.CleanOrder,
        p_norm.CleanItem,
        p_norm.CleanDeductions
    FROM 
        p_norm
    LEFT JOIN 
        m_norm ON p_norm.CleanOrder = m_norm.CleanOrder AND m_norm.rn_fg = 1
    LEFT JOIN 
        item_desc ON p_norm.ITEMNMBR = item_desc.ItemNumber
),

ranked AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (PARTITION BY ORDERNUMBER, FG, ITEMNMBR 
                           ORDER BY Construct, [FG Desc], STSDESCR) AS rn_final
    FROM 
        joined
),

Core AS (
    SELECT *
    FROM 
        ranked
    WHERE 
        rn_final = 1
),

ledger_ranked AS (
    SELECT
        RTRIM(LTRIM(a.MANUFACTUREORDER_I)) AS CleanMO,
        RTRIM(LTRIM(a.ITEMNMBR)) AS ITEMNMBR,
        CAST(a.MRPISSUEDATE_I AS date) AS MRP_IssueDate,
        a.WCID_I,
        a.QTY_ISSUED_I + a.QTY_BACKFLUSHED_I AS Total_Issued,
        a.MRPAMOUNT_I - a.ATYALLOC - a.QTY_ISSUED_I - a.QTY_BACKFLUSHED_I AS Remaining_Required,
        a.MRPAMOUNT_I AS Required_Qty,
        ROW_NUMBER() OVER (PARTITION BY RTRIM(LTRIM(a.MANUFACTUREORDER_I)), RTRIM(LTRIM(a.ITEMNMBR)), a.MRPAMOUNT_I
                           ORDER BY CAST(a.MRPISSUEDATE_I AS date) DESC) AS rn_qty,
        ROW_NUMBER() OVER (PARTITION BY RTRIM(LTRIM(a.MANUFACTUREORDER_I)), RTRIM(LTRIM(a.ITEMNMBR))
                           ORDER BY CASE WHEN (a.QTY_ISSUED_I + a.QTY_BACKFLUSHED_I) > 0 THEN 1 ELSE 2 END, 
                                        ABS(a.MRPAMOUNT_I) DESC, 
                                        CAST(a.MRPISSUEDATE_I AS date) DESC) AS rn_any
    FROM 
        dbo.PK010033 a WITH (NOLOCK)
    LEFT JOIN 
        dbo.IV00101 b WITH (NOLOCK) ON a.ITEMNMBR = b.ITEMNMBR
    WHERE EXISTS (
        SELECT 1
        FROM dbo.WO010032 w WITH (NOLOCK)
        WHERE w.MANUFACTUREORDERST_I IN (2, 3)
          AND RTRIM(LTRIM(w.MANUFACTUREORDER_I)) = RTRIM(LTRIM(a.MANUFACTUREORDER_I))
    )
),

Final AS (
    SELECT
        Core.*,
        ISNULL(ml.MRP_IssueDate, '') AS MRP_IssueDate,
        ISNULL(ml.WCID_I, '') AS WCID_From_MO,
        ISNULL(ml.Total_Issued, 0) AS Issued,
        ISNULL(ml.Remaining_Required, 0) AS Remaining,
        CASE WHEN ISNULL(ml.Total_Issued, 0) > 0 THEN 'YES' ELSE 'NO' END AS Has_Issued,
        CASE WHEN ml.MRP_IssueDate IS NULL OR Core.[Date + Expiry] IS NULL THEN 'NO'
             WHEN ml.MRP_IssueDate <> TRY_CAST(Core.[Date + Expiry] AS date) THEN 'YES'
             ELSE 'NO' END AS IssueDate_Mismatch,
        CASE WHEN ISNULL(ml.Total_Issued, 0) > 0 
             AND Core.[Date + Expiry] IS NOT NULL 
             AND TRY_CAST(Core.[Date + Expiry] AS date) < DATEADD(DAY, -7, CAST(GETDATE() AS date))
             THEN 'YES' ELSE 'NO' END AS Early_Issue_Flag,
        CASE 
            WHEN ml.Required_Qty IS NULL THEN 
                CONCAT(Core.ITEMNMBR, ' - ', Core.[Date + Expiry], ' - ', Core.CleanDeductions)
            ELSE 
                CONCAT(Core.ITEMNMBR, ' - ', Core.[Date + Expiry], ' - ', ml.Required_Qty - ml.Total_Issued)
        END AS Unified_Value
    FROM 
        Core
    LEFT JOIN 
        ledger_ranked ml ON Core.CleanOrder = ml.CleanMO 
                         AND Core.CleanItem = ml.ITEMNMBR 
                         AND ((Core.CleanDeductions = ml.Required_Qty AND ml.rn_qty = 1) OR ml.rn_any = 1)
),

RawData AS (
    SELECT
        f.ITEMNMBR,
        f.ItemDescription,
        f.UOMSCHDL AS UOM,
        f.ORDERNUMBER,
        f.Construct,
        f.DUEDATE,
        f.[Expiry Dates],
        f.[Date + Expiry],
        CAST(f.BEG_BAL_Num AS VARCHAR(50)) AS BEG_BAL,
        f.Original_Deductions AS Deductions,
        f.Original_Expiry AS Expiry,
        f.Original_POs AS [PO's],
        f.Original_Running_Balance AS Running_Balance,
        f.MRP_IssueDate,
        f.WCID_From_MO,
        f.Issued,
        -- Determine Demand: Use Remaining from MO if it exists, otherwise use Original Deduction
        ISNULL(f.Remaining, f.Original_Deductions) AS Demand_Qty,
        ISNULL(inv.Total_QTY_Available, 0) AS Inventory_Qty_Available,
        f.VendorItem,
        f.PRIME_VNDR,
        f.PURCHASING_LT,
        f.PLANNING_LT,
        f.ORDER_POINT_QTY,
        f.SAFETY_STOCK,
        f.FG,
        f.[FG Desc],
        f.STSDESCR,
        f.MRPTYPE,
        f.Unified_Value
    FROM
        Final f
    LEFT JOIN
        (
            -- Inventory logic: Only Slippage or Investigate (0-45 Days)
            SELECT 
                Item_Number, 
                SITE, 
                SUM(QTY_Available) AS Total_QTY_Available
            FROM 
                dbo.Prosenthal_INV_BIN_QTY_wQTYTYPE
            WHERE 
                SITE LIKE 'WC-W%' 
                AND DATEDIFF(DAY, DATERECD, GETDATE()) <= 45
            GROUP BY 
                Item_Number, 
                SITE
        ) inv ON f.ITEMNMBR = inv.Item_Number AND f.WCID_From_MO = inv.SITE
),

ProcessedData AS (
    SELECT
        *,
        -- RULE 1: Stale + Unissued Suppression (7 Day Grace)
        CASE 
            WHEN DUEDATE <= DATEADD(DAY, -7, CAST(GETDATE() AS date)) AND Issued = 0 THEN 1 
            ELSE 0 
        END AS Suppress_Stale,
        
        -- RULE 2: Fence Inventory Suppression (7 Day Forward Fence + Full Coverage)
        CASE 
            WHEN DUEDATE <= DATEADD(DAY, 7, CAST(GETDATE() AS date)) AND Inventory_Qty_Available >= Demand_Qty THEN 1 
            ELSE 0 
        END AS Suppress_Fence,
        
        -- RULE 4: Net Demand Calculation (Partial Coverage)
        CASE 
            WHEN Inventory_Qty_Available > 0 AND Inventory_Qty_Available < Demand_Qty THEN Demand_Qty - Inventory_Qty_Available 
            ELSE Demand_Qty 
        END AS Net_Demand
    FROM
        RawData
)

SELECT
    ITEMNMBR,
    ItemDescription,
    UOM,
    ORDERNUMBER,
    Construct,
    DUEDATE,
    [Expiry Dates],
    [Date + Expiry],
    BEG_BAL,
    Deductions,
    Expiry,
    [PO's],
    Running_Balance,
    MRP_IssueDate,
    WCID_From_MO,
    Issued,
    Demand_Qty AS Original_Required,
    Net_Demand,
    Inventory_Qty_Available,
    -- Operational Notes for Suppressions
    CASE 
        WHEN Suppress_Stale = 1 THEN 'SUPPRESSED: Stale & Unissued'
        WHEN Suppress_Fence = 1 THEN 'SUPPRESSED: Full Coverage in Fence'
        WHEN Inventory_Qty_Available > 0 AND Inventory_Qty_Available < Demand_Qty THEN 'PARTIAL: Demand Netted'
        ELSE 'VALID DEMAND'
    END AS Suppression_Status,
    VendorItem,
    PRIME_VNDR,
    PURCHASING_LT,
    PLANNING_LT,
    ORDER_POINT_QTY,
    SAFETY_STOCK,
    FG,
    [FG Desc],
    STSDESCR,
    MRPTYPE,
    Unified_Value
FROM
    ProcessedData
WHERE
    Suppress_Stale = 0  -- Precedence 1: Remove abandoned intent immediately
    AND Suppress_Fence = 0;
